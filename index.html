<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Vocab Wave Shooter</title>
<style>
  :root { --bg:#0b1020; --panel:#111827; --accent:#5db2ff; --text:#e6eef8; }
  body { margin:0; font-family:Inter,Segoe UI,Arial; background:linear-gradient(180deg,#071026,#091226); color:var(--text); display:flex; height:100vh; }
  #left { width:320px; padding:16px; box-sizing:border-box; background:rgba(0,0,0,0.25); border-right:1px solid rgba(255,255,255,0.03); transition:opacity .25s ease; }
  h1 { font-size:18px; margin:4px 0 12px; }
  label { font-size:13px; opacity:0.9; }
  textarea { width:100%; height:220px; margin-top:8px; resize:vertical; background:#071427; color:var(--text); border:1px solid rgba(255,255,255,0.05); padding:8px; box-sizing:border-box; }
  button { margin-top:8px; padding:8px 10px; background:var(--accent); color:#042233; border:none; cursor:pointer; font-weight:600; }
  #controls { margin-top:12px; display:flex; gap:8px; flex-wrap:wrap; }
  #right { flex:1; position:relative; display:flex; flex-direction:column; align-items:center; justify-content:center; }
  canvas { background:linear-gradient(180deg,#081022,#071628); border-radius:6px; box-shadow:0 6px 30px rgba(2,8,22,0.7); }
  .hud { position:absolute; top:12px; left:12px; font-weight:700; color:var(--text); }
  .hud .row { margin-bottom:6px; }
  .topright { position:absolute; top:12px; right:12px; text-align:right; }
  .footer { position:absolute; bottom:12px; left:12px; font-size:13px; opacity:0.9; }
  .modal { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); background:rgba(2,10,20,0.95); border:1px solid rgba(255,255,255,0.06); padding:18px; border-radius:8px; width:520px; max-width:90%; box-sizing:border-box; z-index:20; }
  .modal h2 { margin:0 0 8px; }
  .modal .q { margin:10px 0 14px; }
  .modal input { width:100%; padding:8px; font-size:16px; box-sizing:border-box; }
  .small { font-size:13px; opacity:0.9; margin-top:6px; }
  .muted { opacity:0.7; font-size:13px; }
  .pill { background:rgba(255,255,255,0.03); padding:6px 8px; border-radius:6px; display:inline-block; margin-right:8px; }
  .promptBox { background:#071827; border:1px dashed rgba(255,255,255,0.04); padding:8px; margin-top:8px; border-radius:6px; font-size:13px; }
  #message { position:absolute; left:50%; top:18px; transform:translateX(-50%); font-weight:700; background:rgba(255,255,255,0.02); padding:8px 12px; border-radius:8px; }
  @media(max-width:900px){ #left{display:none;} }
</style>
</head>
<body>
  <div id="left">
    <h1>Shooter Game for Vocab</h1>
    <label>Paste up to <strong>100</strong> vocab pairs (one per line):</label>
    <textarea id="vocabBox" placeholder="Format examples:
chat:cat
chien,dog
maison=house
libro	TAB	book
..."></textarea>

    <div id="controls">
      <button id="loadVocabBtn">Load Vocab</button>
      <button id="startBtn" disabled>Start Game</button>
    </div>

    <div style="margin-top:12px;">
      <label>Quick options</label>
      <div class="small">
        <label>Bullets per correct answer: <input id="bulletsPerCorrect" type="number" value="4" min="1" max="10" style="width:62px; margin-left:6px;"></label>
      </div>
      <div class="small" style="margin-top:8px;">
        <label>Allowed misses before game over: <input id="maxMisses" type="number" value="5" min="1" max="20" style="width:62px; margin-left:6px;"></label>
      </div>
    </div>

    <div style="margin-top:14px;">
      <div class="muted">Tips</div>
      <ul style="padding-left:18px; opacity:0.95">
        <li>Press <strong>R</strong> to reload and answer a vocab question to gain bullets.</li>
        <li>Once the game starts the vocab panel is hidden (so no cheating).</li>
        <li>Use short lists for testing (5–20 entries); larger lists make the questions more varied.</li>
      </ul>
    </div>

    <!-- Formatting helper (kept) -->
    <div style="margin-top:12px;">
      <div class="muted">Formatting</div>
      <div class="promptBox">
        <strong>Allowed separators:</strong> <code>:</code> <code>=</code> <code>,</code> or <code>(tab)</code> — one pair per line.<br>
        <strong>Parser rules:</strong> first token = displayed word; everything after first separator is the correct answer. Empty lines ignored.
      </div>
    </div>

    <div style="margin-top:12px;">
      <div class="muted">Ready? Load your vocab then press Start.</div>
    </div>
  </div>

  <div id="right">
    <div id="message" style="display:none"></div>
    <div class="hud">
      <div class="row">Bullets: <span id="ammo">0</span></div>
      <div class="row">Score: <span id="score">0</span></div>
      <div class="row">Wave: <span id="wave">0</span></div>
      <div class="row">Misses: <span id="misses">0</span>/<span id="maxMissesDisplay">5</span></div>
    </div>
    <div class="topright">
      <div>Enemies: <span id="enemiesAlive">0</span></div>
      <div style="margin-top:6px;" class="muted"></div>
    </div>

    <canvas id="gameCanvas" width="980" height="640"></canvas>
    <div class="footer"></div>
  </div>

  <!-- Modal for vocab question -->
  <div id="questionModal" class="modal" style="display:none;">
    <h2>Reload — Answer to get bullets</h2>
    <div class="q"><strong>Translate / Answer:</strong> <span id="qWord"></span></div>
    <input id="qInput" autocomplete="off" placeholder="Type correct answer then press Enter" />
    <div class="small muted">Press Enter to submit. Correct answer gives bullets. Wrong answer gives nothing.</div>
  </div>

<script>
(() => {
  // Canvas + context
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  // UI elements
  const leftPanel = document.getElementById('left');
  const vocabBox = document.getElementById('vocabBox');
  const loadVocabBtn = document.getElementById('loadVocabBtn');
  const startBtn = document.getElementById('startBtn');
  const ammoEl = document.getElementById('ammo');
  const scoreEl = document.getElementById('score');
  const waveEl = document.getElementById('wave');
  const enemiesAliveEl = document.getElementById('enemiesAlive');
  const missesEl = document.getElementById('misses');
  const maxMissesInput = document.getElementById('maxMisses');
  const bulletsPerCorrectInput = document.getElementById('bulletsPerCorrect');
  const maxMissesDisplay = document.getElementById('maxMissesDisplay');

  const questionModal = document.getElementById('questionModal');
  const qWordEl = document.getElementById('qWord');
  const qInput = document.getElementById('qInput');
  const message = document.getElementById('message');

  // Game state
  let vocab = []; // array of {word,answer}
  let running = false;
  let paused = false;
  let lastTime = 0;
  let score = 0;
  let wave = 0;
  let enemies = [];
  let bullets = [];
  let ammo = 0;
  let misses = 0;
  let maxMisses = parseInt(maxMissesInput.value,10) || 5;
  maxMissesDisplay.textContent = maxMisses;
  let bulletsPerCorrect = parseInt(bulletsPerCorrectInput.value,10) || 4;
  let player = {
    x: canvas.width/2,
    y: canvas.height - 64,
    w: 56,
    h: 36,
    vx:0,
    ax:0,
    speed: 1100, // px/s^2 acceleration
    maxSpeed: 380, // px/s
    friction: 0.85
  };
  let spawnTimer = 0;
  let spawnInterval = 1.0; // seconds (will be recalculated per wave)
  let enemiesToSpawnThisWave = 6;
  let enemiesRemainingInWave = 0;
  let waveInProgress = false;
  let questionActive = false;
  let currentQuestion = null;

  // Controls
  const keys = {};
  window.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
    // Prevent page scrolling on space
    if (e.key === ' ' || e.key === 'Spacebar') {
      e.preventDefault();
    }
    // Reload key
    if (e.key.toLowerCase() === 'r') {
      if (!questionActive && running && !paused) {
        openQuestion();
      }
    }
  });
  window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

  // Load vocab parsing
  function parseVocab(text) {
    const lines = text.split('\n').map(s => s.trim()).filter(s => s);
    const list = [];
    for (let ln of lines) {
      // Try separators: :,=,comma,tab
      let parts = ln.split(':');
      if (parts.length<2) parts = ln.split('=');
      if (parts.length<2) parts = ln.split(',');
      if (parts.length<2) parts = ln.split('\t');
      if (parts.length<2) {
        // If still single word, skip
        continue;
      }
      const word = parts[0].trim();
      const answer = parts.slice(1).join(':').trim(); // keep anything after first separator
      if (word && answer) list.push({word, answer});
      if (list.length >= 100) break;
    }
    return list;
  }

  loadVocabBtn.addEventListener('click', () => {
    const list = parseVocab(vocabBox.value);
    if (list.length === 0) {
      alert('No valid vocab pairs found. Use formats like "chat:cat" or "chien,dog" (one per line).');
      return;
    }
    vocab = list;
    alert(`Loaded ${vocab.length} vocab pairs (max 100).`);
    startBtn.disabled = false;
  });

  startBtn.addEventListener('click', () => {
    if (vocab.length === 0) { alert('Load vocab first!'); return; }
    // Reset state
    running = true;
    paused = false;
    lastTime = performance.now();
    score = 0;
    wave = 0;
    enemies = [];
    bullets = [];
    // STARTER AMMO: give the player 10 bullets at start
    ammo = 10;
    misses = 0;
    spawnTimer = 0;
    enemiesToSpawnThisWave = 6;
    enemiesRemainingInWave = 0;
    waveInProgress = false;
    questionActive = false;
    startBtn.disabled = true;
    bulletsPerCorrect = parseInt(bulletsPerCorrectInput.value,10) || 4;
    maxMisses = parseInt(maxMissesInput.value,10) || 5;
    maxMissesDisplay.textContent = maxMisses;
    ammoEl.textContent = ammo;
    scoreEl.textContent = score;
    missesEl.textContent = misses;
    showTempMessage('Game started! +10 bullets');

    // ===== HIDE / LOCK VOCAB PANEL TO PREVENT CHEATING =====
    leftPanel.style.display = 'none';
    // additionally disable inputs so they can't be edited via keyboard shortcuts
    vocabBox.disabled = true;
    loadVocabBtn.disabled = true;
    bulletsPerCorrectInput.disabled = true;
    maxMissesInput.disabled = true;

    requestAnimationFrame(loop);
  });

  // Shooting
  function shoot() {
    if (ammo <= 0) {
      // auto open question
      openQuestion();
      return;
    }
    // Create bullet at player's nose
    const bx = player.x;
    const by = player.y - 6;
    bullets.push({
      x: bx,
      y: by,
      vx: 0,
      vy: -760, // px/s
      r: 5
    });
    ammo--;
  }

  // Enemy spawn
  function spawnEnemy() {
    const margin = 40;
    const ex = margin + Math.random() * (canvas.width - margin*2);
    // size slightly smaller on early waves, slightly larger later
    const size = 30 + Math.random()*30;
    // baseSpeed reduced a bit to make early waves gentler
    const baseSpeed = 20 + Math.random()*35;
    const sway = 40 + Math.random()*60;
    enemies.push({
      x: ex,
      y: -size - 10,
      w: size,
      h: size*0.7,
      vy: baseSpeed,
      sway: sway,
      swayOffset: Math.random()*Math.PI*2,
      hp: 1,
      id: Math.random()
    });
  }

  // Open vocab question modal to get bullets
  function openQuestion() {
    if (vocab.length === 0) return;
    // Pause the game loop updates but keep rendering background
    questionActive = true;
    // Pick a random vocab item
    const item = vocab[Math.floor(Math.random()*vocab.length)];
    currentQuestion = item;
    qWordEl.textContent = item.word;
    qInput.value = '';
    questionModal.style.display = 'block';
    qInput.focus();
  }

  // Close modal
  function closeQuestion() {
    questionActive = false;
    currentQuestion = null;
    questionModal.style.display = 'none';
    qInput.value = '';
    // ensure focus goes away
    canvas.focus();
  }

  // Submit answer
  qInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      const guess = qInput.value.trim();
      if (!currentQuestion) return;
      if (guess.length === 0) {
        // allow empty submission (counts as wrong)
        closeQuestion();
        showTempMessage('No answer — no bullets gained.');
        return;
      }
      // Compare case-insensitively and also ignore some punctuation
      const normalize = s => s.toLowerCase().replace(/[^a-zàâäéèêëîïôöùûüçñ0-9 ]/gi, '').trim();
      if (normalize(guess) === normalize(currentQuestion.answer)) {
        // correct
        const amount = bulletsPerCorrect; // could be randomized if you want
        ammo += amount;
        showTempMessage(`Correct! +${amount} bullets`);
      } else {
        showTempMessage(`Wrong — correct: "${currentQuestion.answer}"`);
      }
      closeQuestion();
    }
  });

  // Collision helpers
  function rectCircleCollide(rx, ry, rw, rh, cx, cy, cr) {
    // find closest point
    const closestX = Math.max(rx, Math.min(cx, rx+rw));
    const closestY = Math.max(ry, Math.min(cy, ry+rh));
    const dx = cx - closestX;
    const dy = cy - closestY;
    return (dx*dx + dy*dy) <= cr*cr;
  }

  // Draw helper: rounded rect
  function roundRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  // Temporary message
  let msgTimeout = null;
  function showTempMessage(txt, t=1600){
    message.style.display = 'block';
    message.textContent = txt;
    clearTimeout(msgTimeout);
    msgTimeout = setTimeout(()=>{ message.style.display='none' }, t);
  }

  // Main loop
  function loop(now) {
    if (!running) return;
    if (paused) return;
    const dt = Math.min(0.05, (now - lastTime)/1000);
    lastTime = now;

    update(dt);
    render();

    if (running) requestAnimationFrame(loop);
  }

  // Update game state (dt in seconds)
  function update(dt) {
    // Handle controls
    let left = keys['arrowleft'] || keys['a'] || false;
    let right = keys['arrowright'] || keys['d'] || false;
    if (left && !right) {
      player.vx -= player.speed * dt;
    } else if (right && !left) {
      player.vx += player.speed * dt;
    } else {
      // friction
      player.vx *= Math.pow(player.friction, dt*60);
    }
    // clamp
    if (player.vx > player.maxSpeed) player.vx = player.maxSpeed;
    if (player.vx < -player.maxSpeed) player.vx = -player.maxSpeed;
    player.x += player.vx * dt;

    // bounds
    const half = player.w/2;
    if (player.x < half) { player.x = half; player.vx *= -0.1; }
    if (player.x > canvas.width - half) { player.x = canvas.width - half; player.vx *= -0.1; }

    // Shooting (space)
    if ((keys[' '] || keys['spacebar']) && !questionActive) {
      // simple auto-fire cooldown handled by ammo only to keep it playable
      // prevent continuous firing too fast: add a tiny cooldown per bullet
      if (!shootCooldown) shootCooldown = 0;
      shootCooldown -= dt;
      if (shootCooldown <= 0) {
        if (ammo > 0) {
          shoot();
          shootCooldown = 0.12; // 120ms between shots
        }
      }
    }

    // Update bullets
    for (let i = bullets.length-1; i >= 0; i--) {
      const b = bullets[i];
      b.y += b.vy * dt;
      b.x += b.vx * dt;
      // offscreen
      if (b.y < -20) {
        bullets.splice(i,1);
      }
    }

    // Wave spawn and enemies
    if (!waveInProgress) {
      // start next wave
      wave++;
      waveEl.textContent = wave;

      // =========== DIFFICULTY TUNING ===========
      // make first few waves easy and ramp gradually:
      // enemies start at 3 on wave 1, then slowly increase (+1 per wave roughly)
      enemiesToSpawnThisWave = 3 + Math.floor((wave - 1) * 1.0);

      // spawn interval: starts slow (1.4s) and reduces gradually as waves increase, but capped
      spawnInterval = Math.max(0.3, 1.4 - Math.min(1.0, (wave - 1) * 0.06));

      // store remaining and mark wave started
      enemiesRemainingInWave = enemiesToSpawnThisWave;
      waveInProgress = true;

      // give a softer message for early waves
      if (wave <= 3) {
        showTempMessage('Wave ' + wave + ' — Easy');
      } else if (wave <= 6) {
        showTempMessage('Wave ' + wave + ' — Moderate');
      } else {
        showTempMessage('Wave ' + wave);
      }
    } else {
      // spawning
      spawnTimer += dt;
      if (spawnTimer >= spawnInterval && enemiesRemainingInWave > 0) {
        spawnTimer = 0;
        spawnEnemy();
        enemiesRemainingInWave--;
      }
      // wave finishes when both enemies array empty and remaining to spawn 0
      if (enemiesRemainingInWave === 0 && enemies.length === 0) {
        waveInProgress = false;
      }
    }

    // Update enemies
    for (let i = enemies.length-1; i >= 0; i--) {
      const e = enemies[i];
      // sway motion; make sway growth with wave smaller so it doesn't get too hard too quickly
      e.x += Math.sin((performance.now()/1000)*1.5 + e.swayOffset) * e.sway * 0.003 * (1 + Math.max(0, wave - 1) * 0.02);
      // increase downward speed a little each wave, but not too aggressively
      e.y += (e.vy + Math.max(0, wave - 1) * 2.5) * dt;

      // if reached bottom
      if (e.y > canvas.height + 40) {
        enemies.splice(i,1);
        misses++;
        missesEl.textContent = misses;
        if (misses >= maxMisses) {
          endGame();
          return;
        }
        continue;
      }
      // collisions with bullets
      for (let j = bullets.length-1; j >= 0; j--) {
        const b = bullets[j];
        if (rectCircleCollide(e.x, e.y, e.w, e.h, b.x, b.y, b.r)) {
          // hit
          bullets.splice(j,1);
          e.hp--;
          if (e.hp <= 0) {
            enemies.splice(i,1);
            score += 10;
            scoreEl.textContent = score;
            break;
          }
        }
      }
    }

    // Update HUD
    ammoEl.textContent = ammo;
    enemiesAliveEl.textContent = enemies.length;
  }

  function endGame() {
    running = false;
    startBtn.disabled = false;
    showTempMessage('Game Over! Score: ' + score, 3000);
    alert('Game over! Score: ' + score);

    // ===== RE-ENABLE / SHOW VOCAB PANEL =====
    leftPanel.style.display = 'block';
    vocabBox.disabled = false;
    loadVocabBtn.disabled = false;
    bulletsPerCorrectInput.disabled = false;
    maxMissesInput.disabled = false;
  }

  // Render everything
  function render() {
    // clear
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // background gradient
    const g = ctx.createLinearGradient(0,0,0,canvas.height);
    g.addColorStop(0, '#071323');
    g.addColorStop(1, '#051021');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // stars (subtle)
    for (let i=0;i<40;i++){
      ctx.fillStyle = 'rgba(255,255,255,0.02)';
      const x = (i*97) % canvas.width;
      const y = (i*59 + (performance.now()/30)%canvas.height) % canvas.height;
      ctx.fillRect(x, y, 1, 1);
    }

    // draw player (triangle-ish ship)
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.rotate(Math.max(-0.35, Math.min(0.35, player.vx/400)));
    // body
    ctx.fillStyle = '#6bd1ff';
    roundRect(-player.w/2, -player.h/2, player.w, player.h, 8);
    ctx.fill();
    // cockpit
    ctx.fillStyle = '#02293a';
    roundRect(-player.w/6, -player.h/4, player.w/3, player.h/2, 6);
    ctx.fill();
    ctx.restore();

    // bullets
    ctx.fillStyle = '#ffcc66';
    for (const b of bullets) {
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
    }

    // enemies
    for (const e of enemies) {
      // draw shadow
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      roundRect(e.x-5, e.y+e.h-3, e.w+10, 8, 6);
      ctx.fill();

      // enemy body
      ctx.fillStyle = '#ff6b6b';
      roundRect(e.x, e.y, e.w, e.h, 8);
      ctx.fill();

      // word on enemy? (optional, we keep enemies neutral as requested)
      ctx.fillStyle = '#0b0f14';
      ctx.font = Math.max(12, Math.floor(e.w*0.18)) + 'px system-ui, Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      // optionally show id briefly
      ctx.fillText('☻', e.x + e.w/2, e.y + e.h/2 - 2);
    }
  }

  // allow clicking reload button area: (here user presses R)
  // Keyboard shoot also works

  // small shoot cooldown var
  let shootCooldown = 0;

  // Helper: prevent text selection while playing
  document.addEventListener('selectstart', (e) => { if (running) e.preventDefault(); });

  // Save cursor focus to canvas for space events
  canvas.tabIndex = 1000;
  canvas.style.outline = 'none';
  canvas.addEventListener('click', () => canvas.focus());

  // Prevent accidental form submission interfering
  document.addEventListener('keydown', (e) => {
    // Prevent Enter from adding newline to textarea when game active
    if (e.key === 'Enter' && questionActive) {
      e.preventDefault();
    }
    // handle spacebar for shooting on modern browsers
    if (e.key === ' ' || e.key === 'Spacebar') {
      if (!questionActive && running && !paused) {
        shoot();
        e.preventDefault();
      }
    }
  });

  // Update settings live
  bulletsPerCorrectInput.addEventListener('change', () => {
    bulletsPerCorrect = parseInt(bulletsPerCorrectInput.value,10) || 4;
  });
  maxMissesInput.addEventListener('change', () => {
    maxMisses = parseInt(maxMissesInput.value,10) || 5;
    maxMissesDisplay.textContent = maxMisses;
  });

  // Initial sample vocab
  vocabBox.value = `chat:cat
chien:dog
pomme:apple
maison:house
livre:book
rouge:red
vert:green`;

})();
</script>
</body>
</html>
